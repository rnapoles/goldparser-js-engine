##TEMPLATE-NAME 'Javascript OO Engine'
##LANGUAGE 'Javascript'
##ENGINE-NAME 'Javascript OO Engine'
##AUTHOR 'Reinier Nápoles Martínez'
##FILE-EXTENSION 'js'
##NOTES

The template was based on the Kessels engine.

This template creates a .js file for use by the JS Engine.
The complete CGT (Compiled Grammar Table) is hardcoded into the .js
file, so initializing the engine is very fast (it does not have
to load the CGT file from disk).

This template creates the source for a bare-bones interpreter. The
resulting code is executable and will show the progress of the
interpreter as it executes an input script.

##END-NOTES
##ID-SEPARATOR '_'
##ID-SYMBOL-PREFIX 'Symbol'
##ID-RULE-PREFIX 'rule'
##DELIMITER ','
/*
##PARAMETERS
Name             : %Name%
Version          : %Version%
Author           : %Author%
About            : %About%
Case Sensitive   : %CaseSensitive%
Start Symbol     : %StartSymbol%

Character Set     : %Character-Set%
Character Mapping : %Character-Mapping%
Generated By      : %Generated-By%
Generated Date    : %Generated-Date%

##END-PARAMETERS 

Output File      : %OutputFile% 
Output File Base : %OutputFileBase% 

This file was generated by the Gold Parser.
The template is Javascript OO Engine

*/

const Action = require('./gold/engine/Action');
const Context = require('./gold/engine/Context');
const DfaEdge = require('./gold/engine/DfaEdge');
const DfaState = require('./gold/engine/DfaState');
const Grammar = require('./gold/engine/Grammar');
const LalrState = require('./gold/engine/LalrState');
const Rule = require('./gold/engine/Rule');
const Symbol = require('./gold/engine/Symbol');
const AbstractParser = require('./gold/AbstractParser');

##PARAMETERS
class Base%Name% extends AbstractParser {
##END-PARAMETERS

  parse() {

    let ctx = new Context();
    let result = this.parseInput();

    /* Interpret the results. */
    if (result != this.PARSE_ACCEPT) {
      this.showErrorMessage(result);
    } else {
      if(this.firstToken){
        /* Initialize the Context. */
        ctx.debug = this.debug;
        ctx.indent = 0;
        ctx.returnValue = null;

        /* Start execution by calling the subroutine of the first Token on
         the TokenStack. It's the "Start Symbol" that is defined in the
         grammar. 
        */
        let fn = this.ruleJumpTable[this.firstToken.reductionRule];
        this[fn](this.firstToken,ctx);
      }
    }

  }

  /***** Rule subroutines *****************************************************/

##RULE-TABLE
##RULES
  /* 
    Symbol Count: %SymbolCount%
    %Description% 
    TokenType token
    Context ctx
  */
  %ID%(token,ctx) {
  
    if (ctx.debug >= 2) {
      this.log("Calling %ID%\n");
    }
    
    /*
    //^ %Description%
    */
    this.debugRule(token,ctx); //Replace with your code
  }

##END-RULES
##END-RULE-TABLE

  initGrammar(){

##CHAR-SET-TABLE
##CHAR-SETS
    let grammarCharset%Index%CharCount = %CharCount%;
    let grammarCharset%Index% = [
##CHARS
      %UnicodeIndex%,
##END-CHARS
      0
    ];

##END-CHAR-SETS
##END-CHAR-SET-TABLE

##DFA-TABLE
##DFA-STATES
    let grammarDfaEdgeArray%Index% = [
##DFA-EDGES
      new DfaEdge(%Target%,grammarCharset%CharSetIndex%CharCount,grammarCharset%CharSetIndex%),
##END-DFA-EDGES
      new DfaEdge(-1,0,null)
    ];

##END-DFA-STATES
##END-DFA-TABLE

##RULE-TABLE
##RULES
    let grammarRulesymbolArray%Index% = [
##RULE-SYMBOLS
      %SymbolIndex%,
##END-RULE-SYMBOLS
      -1
    ];

##END-RULES
##END-RULE-TABLE

##LALR-TABLE
##LALR-STATES
    let grammarLalrActionArray%Index% = [
##LALR-ACTIONS
      new Action(%SymbolIndex%,%Action%,%Value%),
##END-LALR-ACTIONS
      new Action(-1,-1,-1)
    ];
##END-LALR-STATES
##END-LALR-TABLE

##SYMBOL-TABLE
    let grammarSymbolArray = [
##SYMBOLS
      /* %Value.Padded% */
      new Symbol(%Kind%,"%Name%")%Delimiter%
##END-SYMBOLS
    ];
##END-SYMBOL-TABLE

##DFA-TABLE
    let grammarDfaStateArray = [
##DFA-STATES
      /* %Index% */
      new DfaState(%AcceptIndex%,%EdgeCount%,grammarDfaEdgeArray%Index%),
##END-DFA-STATES
      new DfaState(-1,-1,null)
    ];
##END-DFA-TABLE

##RULE-TABLE
    let grammarRuleArray = [
##RULES
      /* %Value.Padded% */
      new Rule(%NonterminalIndex%,%SymbolCount%,grammarRulesymbolArray%Index%,"%Description%")%Delimiter%
##END-RULES
    ];
##END-RULE-TABLE

##LALR-TABLE
    let grammarLalrStateArray = [
##LALR-STATES
      /* %Index% */
      new LalrState(%ActionCount%,grammarLalrActionArray%Index%),
##END-LALR-STATES
      new LalrState(-1,null)
    ];
##END-LALR-TABLE

    this.grammar = new Grammar();

##PARAMETERS
    /* CaseSensitive */
    //this.grammar.caseSensitive = %CaseSensitive%;
    /* InitialSymbol */
    //this.grammar.initialSymbol = %StartSymbol%;
##END-PARAMETERS
##DFA-TABLE
    /* InitialDfaState */
    this.grammar.initialDfaState = %InitialState%;
##END-DFA-TABLE
##LALR-TABLE
    /* InitialLalrState */
    this.grammar.initialLalrState = %InitialState%;
##END-LALR-TABLE
##SYMBOL-TABLE
    /* SymbolCount */
    this.grammar.symbolCount = %Count%;
    /* symbolArray */
    this.grammar.symbolArray = grammarSymbolArray;
##END-SYMBOL-TABLE
##RULE-TABLE
    /* RuleCount */
    this.grammar.ruleCount = %Count%;
    /* ruleArray */
    this.grammar.ruleArray = grammarRuleArray;
##END-RULE-TABLE
##DFA-TABLE
    /* DfaStateCount */
    this.grammar.dfaStateCount = %Count%;
    /* DfaArray */
    this.grammar.dfaArray = grammarDfaStateArray;
##END-DFA-TABLE
##LALR-TABLE
    /* LalrStateCount */
    this.grammar.lalrStateCount = %Count%;
    /* LalrArray */
    this.grammar.lalrArray = grammarLalrStateArray;
##END-LALR-TABLE

##RULE-TABLE
    this.ruleJumpTable = [
##RULES
      /* %Index%. %Description% */
      '%ID%'%Delimiter%
##END-RULES
    ];
##END-RULE-TABLE

  }

}

##PARAMETERS
module.exports = Base%Name%;
##END-PARAMETERS 